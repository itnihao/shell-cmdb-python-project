# -*- coding: utf-8 -*-'''  此job中的作用用于执行自动化,从task表取数据'''import json, subprocess, os, atexitfrom signal import signal, SIGTERMfrom application import app, dbfrom models.tasks import Tasksfrom callback import Callbackclass JobsCron:    def run(self):        print "===========start=========="        self.auto_ansible()        print "===========end============"    def auto_ansible(self):        self.atexit_fun()        info=Tasks.query.filter(Tasks.status==Tasks.STATUS_UNPROCESS).order_by(Tasks.id.asc()).first()        if not info:            print "没有任务"            return        tasks=json.loads(info.command)        ansible_error=1        logs=[]        for task in tasks:            if not task:                continue            sp = subprocess.Popen(task,shell=True, stdout=subprocess.PIPE,stderr=subprocess.STDOUT)            while True:                line = sp.stdout.read(400)#sp.stdout.readline()                tmplines = line.split("\n")                if not line:break                for tmpline in tmplines:                    logs.append(unicode(tmpline, errors='ignore'))                    print tmpline                    if 'failed=0' in tmpline:                        ansible_error=0                    if 'ERROR:' in tmpline :                        ansible_error=1            status= sp.wait()            if status: #出错了                ansible_error=1                break            else:      #成功了                if ansible_error  :                    break        if ansible_error:            info.status=Tasks.STATUS_FAIL        else:            info.status=Tasks.STATUS_SUCCESS        info.note=json.dumps(logs)        db.session.commit()        fun_callback=Callback()        getattr(fun_callback,'auto_callback')(info.id)    def atexit_fun(self):        pid_file='/tmp/jqueueprod.pid'        if os.path.isfile(pid_file):            p = open(pid_file).readline().strip()            if p.isdigit() and os.path.isdir('/proc/%s/'%int(p)):                print "Process is in"                exit()            os.remove(pid_file)        signal(SIGTERM, lambda signum, stack_frame: exit(1))        atexit.register(lambda:os.remove(pid_file))        fd=os.open(pid_file,os.O_CREAT|os.O_EXCL|os.O_RDWR)        os.write(fd,"%s\n" % str(os.getpid()))        os.close(fd)