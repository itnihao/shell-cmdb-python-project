# -*- coding: utf-8 -*-
import StringIO
from fabric.api import *
from fabric.contrib import files
from application import db,app
from models.pubkey_changed_queue import PubkeyChangedQueue
from models.user_host import UserHost
from models.sshkey import Sshkey
from models.host import Host
from models.ip_address import IpAddress
from models.user import User
from views.functions import addmail
from views.pool import get_ansible_passwd
from sqlalchemy import and_
from signal import signal, SIGTERM
import datetime,os,sys,atexit, getopt

ROOT_KEY_FILE = '/root/.ssh/authorized_keys'
EVANS_KEY_FILE = '/home/evans/.ssh/authorized_keys'
READONLY_KEY_FILE = '/home/readonly/.ssh/authorized_keys'
DELIMITER_BEGIN = '### Generated by SSH-KEY - BEGIN'
DELIMITER_END = DELIMITER_BEGIN.replace('BEGIN', 'END')
PID_FILE = '/var/run/pubkey_changed.pid'
env.user = 'root'
env.abort_on_prompts = False
#env.skip_bad_hosts = True
env.timeout = 30
env.debug = True
#env.password = '%s'%get_ansible_passwd().strip()
env.password = 'anjukeansible'
env.key_filename = '/root/.ssh/ansible_rsa'
env.abort_exception = True
LANG = "en_US.UTF-8"

def atexit_removepid(pid_file):
    try:
        os.remove(pid_file)
    except:
        pass
    print '---------end--------------'
class Pubkey_Changed:
    def run(self):
        print '---------start--------------'
        self.role_root_users = set()
        self.role_evans_users = set()
        self.role_readonly_users = set()
        sys.exit(self.push_key())

    def push_key(self):
        #阻止重复运行
        pid_file=PID_FILE
        if os.path.isfile(pid_file):
            print("The program is running")
            return 1
        else:
          try:
            signal(SIGTERM, lambda signum, stack_frame: exit(1))
            atexit.register(lambda:atexit_removepid(pid_file))
            fd=os.open(pid_file,os.O_CREAT|os.O_EXCL|os.O_RDWR)
            os.write(fd,"%s\n" % os.getpid())
            os.close(fd)
          except:
            print("Cann't get a lock file")
            return 1

        pubkey_queues = PubkeyChangedQueue.query.filter(PubkeyChangedQueue.my_host_flag == 0).limit(5).all()
        if pubkey_queues:
            uids = []
            for pubkey_queue in pubkey_queues:
                print '------Do Queue:%s-----------'%pubkey_queue.id
                tmp_uid = pubkey_queue.uid
                if tmp_uid not in uids:
                    uids.append(tmp_uid)
                pubkey_queue.my_host_flag = 1
                db.session.commit()
            if len(uids) <=0:
                return
            UserHosts = UserHost.query.filter(and_(UserHost.uid.in_(uids),UserHost.status == UserHost.STATUS_VALID)).all()
            if UserHosts:
                for userhost in UserHosts:
                    self.getUids(userhost.host_id)
                    self.do_task(userhost.host_id)
                    self.role_root_users = set()
                    self.role_evans_users = set()
                    self.role_readonly_users = set()

                    userhost.status = UserHost.STATUS_OVERDUE
                    db.session.commit()

    def getUids(self,host_id):
        host_users = UserHost.query.filter(and_(UserHost.host_id == host_id, UserHost.status == UserHost.STATUS_VALID)).all()
        if host_users:
            for host_user in host_users:
                self.setUids(host_user.role,host_user.uid)


    def setUids(self,role,uid):
        if int(role) == UserHost.ROLE_ROOT:
            self.role_root_users.add(uid)
            self.role_evans_users.add(uid)
            self.role_readonly_users.add(uid)

        elif int(role) == UserHost.ROLE_EVANS:
            self.role_evans_users.add(uid)
            self.role_readonly_users.add(uid)

        elif int(role) == UserHost.ROLE_READONLY:
            self.role_readonly_users.add(uid)

    def do_task(self,host_id):
        try:
            params = dict()
            role_root_users = self.role_root_users
            role_evans_users = self.role_evans_users
            role_readonly_users = self.role_readonly_users
            #get ip
            host_info = Host.query.filter(Host.id == host_id).first()
            ip = self._get_ip(host_info.id)
            env.host = ip
            execute(self.check_remote_file, host=env.host)

            params['key_file'] = ROOT_KEY_FILE
            params['keys'] = self.get_keys(role_root_users)
            self.proceess_task(ip, params)

            #readonly
            params['key_file'] = READONLY_KEY_FILE
            params['keys'] = self.get_keys(role_readonly_users)
            self.proceess_task(ip, params)

            evans_home = execute(self.process_check_evans_home, host=env.host)
            if evans_home[env.host]:
                params['key_file'] = '/home/www/.ssh/authorized_keys'
            else:
                params['key_file'] = EVANS_KEY_FILE

            params['keys'] = self.get_keys(role_evans_users)
            self.proceess_task(ip, params)
            return True
        except Exception , e:
            print e
            return False

    def _get_ip(self,host_id):
        host_info = Host.query.filter(Host.id == host_id).first()
        ip_info = IpAddress.query.filter(IpAddress.id == host_info.primary_ip_id).first()
        return ip_info.ipv4

    def process_check_evans_home(self):
        evans_home = run("cat /etc/passwd| grep evans")
        evans_list = evans_home.split(":")
        #if evans_list[5] == '/home/evans':
        if '/home/evans' in evans_home:
            return False
        return True

    def get_keys(self,user_ids):
        keys = set()
        root_user_keys = Sshkey.query.filter(Sshkey.uid.in_(user_ids)).all()
        for root_user_key in root_user_keys:
                keys.add(root_user_key.key)
        return keys
    def proceess_task(self,host_ip, params):
        execute(self.build_host, params, host=env.host)

    def check_remote_file(self):
        self.create_remote_file(ROOT_KEY_FILE, 'root', 'root')
        self.create_remote_file(EVANS_KEY_FILE, 'evans', 'www-data')
        self.create_remote_file(READONLY_KEY_FILE, 'readonly', 'readonly')

    def create_remote_file(self,remote_file, user, group):
        remote_dir = remote_file[0:-16]
        if not files.exists(remote_dir, use_sudo=False, verbose=True):
            run("mkdir -p "+remote_dir+" && chown -R "+user+":"+group+" "+remote_dir+" && chmod 700 "+remote_dir)
        if not files.exists(remote_file, use_sudo=False, verbose=True):
            run("touch "+remote_file+" && chown "+user+":"+group+" "+remote_file+" && chmod 600 "+remote_file)

    def build_host(self,params):
        print 'Build host ip %s, %d keys.' % (env.host, len(params['keys']))
        f_in = StringIO.StringIO()
        get(params['key_file'], f_in)
        f_in.seek(0)  #defaults to 0 (absolute file positioning); other values are 1 (seek relative to the current position) and 2 (seek relative to the file's end).
        f_out = StringIO.StringIO()
        within = False
        for line in f_in:
            if within:
                if line.startswith(DELIMITER_END):
                    within = False

            elif line.startswith(DELIMITER_BEGIN):
                within = True

            else:
                f_out.write(line)
                if not line.endswith('\n'):
                    f_out.write('\n')

        if params['keys']:
            f_out.write(DELIMITER_BEGIN + '\n')
            for key in params['keys']:
                f_out.write(key + '\n' + '\n')
            f_out.write(DELIMITER_END + '\n')

        put(f_out, params['key_file'])

        f_in.close()
        f_out.close()


